defmodule Khf1 do

  @moduledoc """
  101 dogs
  @author "Hain Balázs Márk <hainb@edu.bme.hu>"
  @date   "2021-09-26"

  """

  @doc """
  variant - type representing variation. consists of {h, d} pairs, where h is the shortest
  row, while d represents the variation in row size.

  seatings - type representing a seating. It consists of {n, vs} pairs, where n specifies that
  the number of rows in which k dogs were seated, and vs the variation of n rows
  they can be placed in.

  """
  @type variant :: { h :: integer, d :: integer }
  @type seatings :: { n :: integer, vs :: [ variant ] }

  @doc """
  is_arithm_s? checks that the arithmetic function n, h, d is
  is indeed a sum of k or not.
  So it tests the truth of ni = 0 -> n: sum(h + ni*d) == k.
  Local function.
  """
  @spec is_arithm_s?( n :: integer,  h :: integer,  d :: integer,  k :: integer ) :: b :: boolean
  defp is_arithm_s?(n, h, d, k) do
    s = (2*h + (n-1)*d) * n
    rem(s, 2) == 0 and div(s, 2) == k
  end

  @doc """
  The sit! function returns a pair that gives you how many different good planting
  exist, and a list of them.

  A planting is then good k dogs can be planted in n > 2 rows such that the
  h puppies sit in the backmost row, and their number increases by exactly d per row.

  The solutions are generated by the solutions function, while sit! is used to generate the format
  to the appropriate format.
  """
  @spec sit!( k :: integer ) :: r :: { m :: integer, ss :: [ seatings ] }
  # k puppies can sit in n>2 rows in m ways, so that the backmost row
  # h puppies sit in the last row, and their number increases by exactly d per row

  def sit!(k) do
    f = solutions(k)
    {m, ss} = Enum.reduce(f, {0, %{}}, fn {n, vs}, {cnt, map} ->
      {cnt+1, Map.update(map, n, [vs], fn existing_value -> existing_value ++ [vs] end)} end)

    {m, Map.to_list(ss)}
  end

  @doc """
  An auxiliary function that performs the planting k on dog, but only all the
  number of solutions, without performing the aggregation into a set, so
  the function good_flocks gains performance.

  Limits and justification:
  2 < n < ceil(k/2)
  0 < h < k / n < ceil(k / 2)
  0 < d < k / n < ceil(k / 2)

  can be checked by substitution into the sum formula
  or intuitively
  1: k = (a1 + an) * n / 2 --> k = cn/2
     for the smallest occurrence c with n > 2: c = 4 (ai = {1, 2, 3})
     n = 2/c * k 2/c < 1/2 --> n <= k/2

  2: with d = 0, the length of the rows is k/n if d > 0 --> h < k/n
  3: if d >= k/n h <= 0
  further n>2

  """
  @spec solutions( k :: integer ) :: r :: [ seatings ]
  defp solutions(k) when k < 3, do: []
  defp solutions(k) do
    ns = 3..div(k, 2) + 1
    hds = 1..div(k, 2) + 1
    for n <- ns, h <- hds, d <- hds, h < div(k, n) + 1,  d < div(k, n) + 1, is_arithm_s?(n, h, d, k), do: {n, {h, d}}
  end

  @doc """
  The function good_flocks gives the number of dog packs,
  which is at most kmax, and the pack can be dropped under the given conditions.

  Original idea, rewritten for efficiency:
  def good_flocks(kmax) do
    for k <- 6..kmax, {key, _} = sit!(k), key != 0, do: k
  end
  """
  @spec good_flocks( kmax :: integer ) :: ks :: [k :: integer]
  # The elements of the list ks are the number of dog packs of which k
  # (2 < k <= kmax) which, under the conditions given in the problem
  # can be placed in front of the screen

  def good_flocks(kmax) when kmax < 6, do: []
  def good_flocks(kmax) do
    for k <- 6..kmax, s = Enum.count(solutions(k)), s != 0, do: k
  end

end
